<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Tucunar√©</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <!--<link rel="icon" type="image/x-icon" href="favicon.ico">-->
  <!--<link rel="stylesheet" type="text/css" href="styles.css"></link>-->
  <style type="text/css">
    * {
      margin: 0; padding: 0;
      box-sizing: border-box;
    }
    body {
      position: absolute;
      top: 0; left: 0;
      width: 100vw;
      height: 100vh;
    }
    #main-canvas {
      background-color: black;
      position: absolute;
      top: 0; left: 0;
      width: 100vw;
      height: 100vh;
    }
  </style>

  <script type="text/javascript" src="keys.js"     ></script>
  <script type="text/javascript" src="vector.js"   ></script>
  <script type="text/javascript" src="matrix.js"   ></script>
  <script type="text/javascript" src="mathutils.js"></script>
  <script type="text/javascript" src="tucunareShader.js" ></script>
  <script type="text/javascript" src="shaders.js"  ></script>

  <script type="text/javascript">
    var keysDown = [];

    var vertShader = new Shader();
    vertShader.main = function(input) {
      return {
        position: this.uniforms.mvp.multiplyV4(input.point),
        output: {
          color: input.color
        }
      }
    };
    var fragShader = new Shader();
    fragShader.main = function(input) {
      return input.color;
    };

    function main() {
      // TODO (maybe)
      // 1) webworkers

      var canvas = document.getElementById("main-canvas");
      var tc = new Tucunare(canvas);
      var pMat = new mat4();

      function windowResized() {
        var width = window.innerWidth;
        var height = window.innerHeight;
        tc.resize(width, height);
        pMat = mat4.perspectiveAR(width / height, 75, 0.1, 1000 * 1000);
      };
      window.onresize = windowResized;
      windowResized();

      var points1 = [];
      var colors1 = [];
      var numPoints = 1000;
      var radius = 2;
      var origin = new vec3(0,0,0);
      for (var i = 0; i < numPoints; i++) {
        var p = new vec3(
          MathUtils.randomFloat(-radius, radius),
          MathUtils.randomFloat(-radius, radius),
          MathUtils.randomFloat(-radius, radius));
        var dist = origin.distance(p);
        var optionA = (dist < radius && dist > (radius - (radius * 0.05)));
        var optionB = (dist < (radius * 0.5));
        if (optionA || optionB) {
          p = new vec4(p.x, p.y, p.z, 1);
          points1.push(p);
          var other = 1.25 - (dist / radius);
          var c = new vec4(other, 1, other, 1);
          // var c = new vec4(MathUtils.randomFloat(0,1), MathUtils.randomFloat(0,1), MathUtils.randomFloat(0,1), 1);
          colors1.push(c);
        }
        else {
          i--;
        }
      }

      // triangle lines
      // var points2 = [];
      // var colors2 = [];
      // var vert1 = new vec4(   0,  500, 0, 1);
      // var vert2 = new vec4( 500, -400, 0, 1);
      // var vert3 = new vec4(-500, -500, 0, 1);
      // var color1 = new vec4(1, 0, 0, 1);
      // var color2 = new vec4(0, 1, 0, 1);
      // var color3 = new vec4(0, 0, 1, 1);
      // points2.push(vert1, vert2, vert2, vert3, vert3, vert1);
      // colors2.push(color1, color2, color2, color3, color3, color1);

      // cube lines
      var points2 = [];
      var colors2 = [];
      var hs = 2;
      var left   = -hs; var right = hs;
      var bottom = -hs; var top   = hs;
      var near   = hs; var far   = -hs;
      var lbn = new vec4(left,  bottom, near, 1);
      var rbn = new vec4(right, bottom, near, 1);
      var ltn = new vec4(left,  top,    near, 1);
      var rtn = new vec4(right, top,    near, 1);
      var lbf = new vec4(left,  bottom, far,  1);
      var rbf = new vec4(right, bottom, far,  1);
      var ltf = new vec4(left,  top,    far,  1);
      var rtf = new vec4(right, top,    far,  1);
      points2.push(
        lbn, rbn, rbn, rtn, rtn, ltn, ltn, lbn, // near
        rbf, lbf, lbf, ltf, ltf, rtf, rtf, rbf, // far
        lbf, lbn, lbn, ltn, ltn, ltf, ltf, lbf, // left
        rbn, rbf, rbf, rtf, rtf, rtn, rtn, rbn  // right
      );
      var color = new vec4(0,1,0,1);
      for (var i = 0; i < points2.length; i++) {
        colors2.push(new vec4(MathUtils.randomFloat(0,1), MathUtils.randomFloat(0,1), MathUtils.randomFloat(0,1), 1));
      }


      var points3 = [];
      var colors3 = [];
      var hs = 1;
      var bl = new vec4(-hs,-hs, 0, 1);
      var tr = new vec4( hs, hs, 0, 1);
      var br = new vec4( hs,-hs, 0, 1);
      var tl = new vec4(-hs, hs, 0, 1);
      points3.push(
        bl, br, tr,
        bl, tr, tl
      );
      var red    = new vec4(1, 0, 0, 1);
      var green  = new vec4(0, 1, 0, 1);
      var blue   = new vec4(0, 0, 1, 1);
      var yellow = new vec4(1, 1, 0, 1);
      colors3.push(
        red, yellow, blue,
        red, blue, green
      );

      // var points3 = [];
      // var colors3 = [];
      // points3.push(
      //   new vec4(-500,-500, 0, 1),
      //   new vec4( 500,-500, 0, 1),
      //   new vec4(   0, 500, 0, 1));
      // colors3.push(
      //   new vec4(1, 0, 0, 1),
      //   new vec4(0, 1, 0, 1),
      //   new vec4(0, 0, 1, 1));

      var rotation = 0;
      var camPos = new vec4(0, 0, 10, 1);
      for (var i = 0; i < 256; i++) keysDown[i] = false;

      // Event handlers
      document.onkeydown = function(e) {
        keysDown[e.keyCode] = true;
        if (e.keyCode === KEYS.ENTER) {
          rotation = (rotation === 0) ? 70 : 0;
        }
      };
      document.onkeyup = function(e) {
        keysDown[e.keyCode] = false;
      };
      document.addEventListener("mousemove", function(e) {
      }, false);

      // points1 = [new vec4(0,0,-1,1)];
      // colors1 = [new vec4(1,1,1,1)];
      function loop() {
        var v = 0.1;
        if (keysDown[KEYS.A   ]) camPos.x -= v;
        if (keysDown[KEYS.D   ]) camPos.x += v;
        if (keysDown[KEYS.DOWN]) camPos.y -= v;
        if (keysDown[KEYS.UP  ]) camPos.y += v;
        if (keysDown[KEYS.W   ]) camPos.z -= v;
        if (keysDown[KEYS.S   ]) camPos.z += v;

        tc.clear();

        var view = mat4.translate(-camPos.x, -camPos.y, -camPos.z);
        var mvp = pMat.multiply(view.multiply(mat4.rotateY(rotation)));
        vertShader.uniforms.mvp = mvp;

        vertShader.incoming.point = points1;
        vertShader.incoming.color = colors1;
        tc.drawPoints(vertShader, fragShader);

        vertShader.incoming.point = points2;
        vertShader.incoming.color = colors2;
        tc.drawLines(vertShader, fragShader);

        vertShader.incoming.point = points3;
        vertShader.incoming.color = colors3;
        tc.drawTriangles(vertShader, fragShader);

        // tc.drawPoints(points1, colors1, mvp);
        // tc.drawLines(points2, colors2, mvp);
        // tc.drawTriangles(points3, colors3, mvp);

        tc.flush();

        if (keysDown[KEYS.R]) {
          rotation += 1;
        }
      }

      loop();
      var animFrame = (
        window.requestAnimationFrame    || window.webkitRequestAnimationFrame ||
        window.mozRequestAnimationFrame || window.oRequestAnimationFrame      ||
        window.msRequestAnimationFrame  || null);

      if (animFrame !== null) {
        function recursiveAnim() {
          loop();
          animFrame(recursiveAnim, canvas);
        }
        // start the mainloop
        animFrame(recursiveAnim, canvas);
      }
      else {
        setInterval(loop, 1000.0 / 60.0);
      }
    }
  </script>
</head>
<body onload="main()">
  <canvas id="main-canvas"></canvas>
</body>
</html>
